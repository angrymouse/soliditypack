{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-309dc64c26e9b0680caf0e767bac9c02027a25a0",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/examples/BytecodeSizeDemo.sol": "project/contracts/examples/BytecodeSizeDemo.sol",
    "contracts/examples/ImprovedAPIExample.sol": "project/contracts/examples/ImprovedAPIExample.sol",
    "contracts/examples/NestedStructuresExample.sol": "project/contracts/examples/NestedStructuresExample.sol",
    "contracts/examples/SequentialEncodingExample.sol": "project/contracts/examples/SequentialEncodingExample.sol",
    "contracts/SPack.sol": "project/contracts/SPack.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/examples/BytecodeSizeDemo.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../SPack.sol\";\nimport \"../SolidityPackTypes.sol\";\n\n/**\n * @title MinimalContractOldAPI\n * @notice Minimal contract using SPack verbose style\n * @dev Used to measure bytecode size impact\n */\ncontract MinimalContractOldAPI {\n    function encode() external pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        SPack.map(b, 3);\n        SPack.s(b, \"name\");\n        SPack.s(b, \"Alice\");\n        SPack.s(b, \"age\");\n        SPack.u(b, 30);\n        SPack.s(b, \"balance\");\n        SPack.u(b, 1000000);\n        return SPack.done(b);\n    }\n}\n\n/**\n * @title MinimalContractNewAPI\n * @notice Minimal contract using SPack chainable style\n * @dev Used to measure bytecode size impact\n */\ncontract MinimalContractNewAPI {\n    function encode() external pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        SPack.map(b, 3);\n        SPack.s(b, \"name\");\n        SPack.s(b, \"Alice\");\n        SPack.s(b, \"age\");\n        SPack.u(b, 30);\n        SPack.s(b, \"balance\");\n        SPack.u(b, 1000000);\n        return SPack.done(b);\n    }\n}\n\n/**\n * HOW TO MEASURE BYTECODE SIZE:\n *\n * 1. Compile both contracts:\n *    npx hardhat compile\n *\n * 2. Check artifact sizes:\n *    ls -lh artifacts/contracts/examples/BytecodeSizeDemo.sol/\n *\n * 3. Or programmatically:\n *    const oldAPI = await ethers.getContractFactory(\"MinimalContractOldAPI\");\n *    const newAPI = await ethers.getContractFactory(\"MinimalContractNewAPI\");\n *    console.log(\"Old API bytecode:\", oldAPI.bytecode.length / 2, \"bytes\");\n *    console.log(\"New API bytecode:\", newAPI.bytecode.length / 2, \"bytes\");\n *\n * EXPECTED RESULT:\n * Both contracts should have IDENTICAL bytecode size since they use the same code.\n * SPack is designed to be concise and gas-efficient with minimal overhead.\n *\n * The SPack library provides:\n * 1. Short, memorable function names (s, u, a, b, map, arr, etc.)\n * 2. Builder pattern for clean, readable code\n * 3. Optimized internal implementations\n * 4. Zero runtime gas overhead vs manual encoding\n * 5. Smaller bytecode compared to verbose APIs\n */\n"
      },
      "project/contracts/examples/ImprovedAPIExample.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../SPack.sol\";\nimport \"../SolidityPackTypes.sol\";\n\n/**\n * @title ImprovedAPIExample\n * @notice Demonstrates the improved SPack API for encoding objects\n * @dev Shows both the old verbose way and the new concise way\n */\ncontract ImprovedAPIExample {\n\n    /**\n     * @notice OLD WAY: Verbose encoding with separate key and value calls\n     * @dev Requires 2 lines per field (encodeKey + encodeValue)\n     */\n    function encodeUserDataOldWay() public pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        SPack.map(b, 4);\n        SPack.s(b, \"name\");\n        SPack.s(b, \"Alice\");\n        SPack.s(b, \"age\");\n        SPack.u(b, 30);\n        SPack.s(b, \"active\");\n        SPack.bool_(b, true);\n        SPack.s(b, \"balance\");\n        SPack.u(b, 1000000);\n        return SPack.done(b);\n    }\n\n    /**\n     * @notice NEW WAY: Concise encoding with SPack builder\n     * @dev Same as old way - SPack is already concise!\n     */\n    function encodeUserDataNewWay() public pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        SPack.map(b, 4);\n        SPack.s(b, \"name\");\n        SPack.s(b, \"Alice\");\n        SPack.s(b, \"age\");\n        SPack.u(b, 30);\n        SPack.s(b, \"active\");\n        SPack.bool_(b, true);\n        SPack.s(b, \"balance\");\n        SPack.u(b, 1000000);\n        return SPack.done(b);\n    }\n\n    /**\n     * @notice Example with complex types including arrays and addresses\n     */\n    function encodeComplexObject() public pure returns (bytes memory) {\n        // Create some test data\n        uint256[] memory scores = new uint256[](3);\n        scores[0] = 95;\n        scores[1] = 87;\n        scores[2] = 92;\n\n        address[] memory addresses = new address[](2);\n        addresses[0] = 0x742d35cC6634c0532925A3b844bc9E7595F0beB1;\n        addresses[1] = 0x1234567890123456789012345678901234567890;\n\n        SPack.Builder memory b = SPack.builder();\n        SPack.map(b, 5);\n        SPack.s(b, \"name\");\n        SPack.s(b, \"Bob\");\n        SPack.s(b, \"wallet\");\n        SPack.a(b, 0x742d35cC6634c0532925A3b844bc9E7595F0beB1);\n        SPack.s(b, \"hash\");\n        SPack.b32(b, keccak256(\"test\"));\n        SPack.s(b, \"scores\");\n        SPack.arr(b, scores.length);\n        for (uint256 i = 0; i < scores.length; i++) {\n            SPack.u(b, scores[i]);\n        }\n        SPack.s(b, \"contacts\");\n        SPack.arr(b, addresses.length);\n        for (uint256 i = 0; i < addresses.length; i++) {\n            SPack.a(b, addresses[i]);\n        }\n        return SPack.done(b);\n    }\n\n    /**\n     * @notice Nested object example - you can still use manual control for nesting\n     */\n    function encodeNestedObject() public pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        SPack.map(b, 3);\n        SPack.s(b, \"userId\");\n        SPack.s(b, \"user123\");\n        SPack.s(b, \"version\");\n        SPack.u(b, 1);\n        SPack.s(b, \"settings\");\n        SPack.map(b, 2);\n        SPack.s(b, \"notifications\");\n        SPack.bool_(b, true);\n        SPack.s(b, \"theme\");\n        SPack.s(b, \"dark\");\n        return SPack.done(b);\n    }\n\n    /**\n     * @notice Real-world example: Encode transaction data\n     */\n    function encodeTransaction(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 nonce,\n        bytes32 txHash\n    ) public pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        SPack.map(b, 5);\n        SPack.s(b, \"from\");\n        SPack.a(b, from);\n        SPack.s(b, \"to\");\n        SPack.a(b, to);\n        SPack.s(b, \"amount\");\n        SPack.u(b, amount);\n        SPack.s(b, \"nonce\");\n        SPack.u(b, nonce);\n        SPack.s(b, \"txHash\");\n        SPack.b32(b, txHash);\n        return SPack.done(b);\n    }\n}\n"
      },
      "project/contracts/examples/NestedStructuresExample.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../SPack.sol\";\nimport \"../SolidityPackDecoder.sol\";\nimport \"../SolidityPackTypes.sol\";\n\n/**\n * @title NestedStructuresExample\n * @notice Demonstrates encoding and decoding nested maps and arrays\n */\ncontract NestedStructuresExample {\n    using SPack for *;\n    using SolidityPackDecoder for *;\n\n    // Example 1: Map with nested map\n    // Structure: {outer: 42, nested: {inner: 100, name: \"test\"}}\n    function encodeNestedMap() public pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        SPack.map(b, 2);              // Outer map: 2 entries\n        SPack.s(b, \"outer\");          // Entry 1: key\n        SPack.u(b, 42);               // Entry 1: value\n        SPack.s(b, \"nested\");         // Entry 2: key\n        SPack.map(b, 2);              // Entry 2: value is a MAP!\n        SPack.s(b, \"inner\");          // Nested key 1\n        SPack.u(b, 100);              // Nested value 1\n        SPack.s(b, \"name\");           // Nested key 2\n        SPack.s(b, \"test\");           // Nested value 2\n        return SPack.done(b);\n    }\n\n    // Example 2: Map with array value\n    // Structure: {name: \"Alice\", scores: [10, 20, 30]}\n    function encodeMapWithArray() public pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        SPack.map(b, 2);\n        SPack.s(b, \"name\");\n        SPack.s(b, \"Alice\");\n        SPack.s(b, \"scores\");\n        SPack.arr(b, 3);              // Array as value!\n        SPack.u(b, 10);\n        SPack.u(b, 20);\n        SPack.u(b, 30);\n        return SPack.done(b);\n    }\n\n    // Example 3: Complex nesting\n    // Structure: {id: 1, data: {tags: [\"a\", \"b\"], active: true}, count: 5}\n    function encodeComplexNesting() public pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        SPack.map(b, 3);              // Level 1: Map with 3 entries\n        SPack.s(b, \"id\");\n        SPack.u(b, 1);\n        SPack.s(b, \"data\");\n        SPack.map(b, 2);              // Level 2: Nested map\n        SPack.s(b, \"tags\");\n        SPack.arr(b, 2);              // Level 3: Array in nested map\n        SPack.s(b, \"a\");\n        SPack.s(b, \"b\");\n        SPack.s(b, \"active\");\n        SPack.bool_(b, true);\n        SPack.s(b, \"count\");\n        SPack.u(b, 5);\n        return SPack.done(b);\n    }\n\n    // Decode Example 1: Step by step\n    function decodeNestedMapStepByStep() public pure returns (\n        uint256 outerValue,\n        uint256 nestedInner,\n        string memory nestedName\n    ) {\n        // Get encoded data\n        bytes memory data = encodeNestedMap();\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        // Step 1: Decode outer map\n        uint256 outerLen = SolidityPackDecoder.decodeMapLength(dec);\n        require(outerLen == 2, \"Expected 2 entries\");\n\n        // Step 2: Decode first entry\n        string memory key1 = SolidityPackDecoder.decodeString(dec);\n        require(keccak256(bytes(key1)) == keccak256(\"outer\"), \"Expected 'outer'\");\n        outerValue = SolidityPackDecoder.decodeUint(dec);\n\n        // Step 3: Decode second entry key\n        string memory key2 = SolidityPackDecoder.decodeString(dec);\n        require(keccak256(bytes(key2)) == keccak256(\"nested\"), \"Expected 'nested'\");\n\n        // Step 4: Check that value is a map\n        SolidityPackDecoder.TypeCategory cat = SolidityPackDecoder.peekCategory(dec);\n        require(cat == SolidityPackDecoder.TypeCategory.MAP, \"Expected nested map\");\n\n        // Step 5: Decode nested map\n        uint256 nestedLen = SolidityPackDecoder.decodeMapLength(dec);\n        require(nestedLen == 2, \"Expected 2 nested entries\");\n\n        // Nested entry 1\n        SolidityPackDecoder.decodeString(dec); // key \"inner\"\n        nestedInner = SolidityPackDecoder.decodeUint(dec);\n\n        // Nested entry 2\n        SolidityPackDecoder.decodeString(dec); // key \"name\"\n        nestedName = SolidityPackDecoder.decodeString(dec);\n\n        return (outerValue, nestedInner, nestedName);\n    }\n\n    // Decode Example 2: Using type inspection\n    function decodeMapWithArrayUsingInspection() public pure returns (\n        string memory name,\n        uint256 firstScore,\n        uint256 scoresCount\n    ) {\n        bytes memory data = encodeMapWithArray();\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        uint256 mapLen = SolidityPackDecoder.decodeMapLength(dec);\n\n        for (uint256 i = 0; i < mapLen; i++) {\n            string memory key = SolidityPackDecoder.decodeString(dec);\n\n            if (keccak256(bytes(key)) == keccak256(\"name\")) {\n                // We know this is a string\n                name = SolidityPackDecoder.decodeString(dec);\n            } else if (keccak256(bytes(key)) == keccak256(\"scores\")) {\n                // Check if it's an array\n                require(\n                    SolidityPackDecoder.isCategory(dec, SolidityPackDecoder.TypeCategory.ARRAY),\n                    \"Expected array\"\n                );\n\n                scoresCount = SolidityPackDecoder.decodeArrayLength(dec);\n                firstScore = SolidityPackDecoder.decodeUint(dec);\n\n                // Skip the rest of the array\n                for (uint256 j = 1; j < scoresCount; j++) {\n                    SolidityPackDecoder.skip(dec);\n                }\n            } else {\n                // Unknown field, skip it\n                SolidityPackDecoder.skip(dec);\n            }\n        }\n\n        return (name, firstScore, scoresCount);\n    }\n\n    // Decode Example 3: Generic decoding with recursion-like pattern\n    function decodeComplexAndExtractTags() public pure returns (\n        string memory firstTag,\n        string memory secondTag,\n        bool foundTags\n    ) {\n        bytes memory data = encodeComplexNesting();\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        uint256 mapLen = SolidityPackDecoder.decodeMapLength(dec);\n\n        for (uint256 i = 0; i < mapLen; i++) {\n            string memory key = SolidityPackDecoder.decodeString(dec);\n\n            if (keccak256(bytes(key)) == keccak256(\"data\")) {\n                // This is the nested map we want\n                uint256 dataMapLen = SolidityPackDecoder.decodeMapLength(dec);\n\n                for (uint256 j = 0; j < dataMapLen; j++) {\n                    string memory nestedKey = SolidityPackDecoder.decodeString(dec);\n\n                    if (keccak256(bytes(nestedKey)) == keccak256(\"tags\")) {\n                        // Found the tags array!\n                        uint256 tagsLen = SolidityPackDecoder.decodeArrayLength(dec);\n                        if (tagsLen >= 2) {\n                            firstTag = SolidityPackDecoder.decodeString(dec);\n                            secondTag = SolidityPackDecoder.decodeString(dec);\n                            foundTags = true;\n\n                            // Skip remaining tags\n                            for (uint256 k = 2; k < tagsLen; k++) {\n                                SolidityPackDecoder.skip(dec);\n                            }\n                        }\n                    } else {\n                        // Skip other nested fields\n                        SolidityPackDecoder.skip(dec);\n                    }\n                }\n            } else {\n                // Skip other top-level fields\n                SolidityPackDecoder.skip(dec);\n            }\n        }\n\n        return (firstTag, secondTag, foundTags);\n    }\n\n    // Example: What if you start a map but then need to skip unknown nested structures?\n    function decodeUnknownStructureWithSkip() public pure returns (\n        uint256 id,\n        uint256 count\n    ) {\n        bytes memory data = encodeComplexNesting();\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        uint256 mapLen = SolidityPackDecoder.decodeMapLength(dec);\n\n        for (uint256 i = 0; i < mapLen; i++) {\n            string memory key = SolidityPackDecoder.decodeString(dec);\n\n            if (keccak256(bytes(key)) == keccak256(\"id\")) {\n                id = SolidityPackDecoder.decodeUint(dec);\n            } else if (keccak256(bytes(key)) == keccak256(\"count\")) {\n                count = SolidityPackDecoder.decodeUint(dec);\n            } else {\n                // Skip the entire \"data\" nested map without caring about its structure!\n                // The skip() function handles nested structures automatically\n                SolidityPackDecoder.skip(dec);\n            }\n        }\n\n        return (id, count);\n    }\n}\n"
      },
      "project/contracts/examples/SequentialEncodingExample.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../SPack.sol\";\nimport \"../SolidityPackDecoder.sol\";\nimport \"../SolidityPackTypes.sol\";\n\n/**\n * @title SequentialEncodingExample\n * @notice Demonstrates what happens when you encode data after a map\n */\ncontract SequentialEncodingExample {\n    using SPack for *;\n    using SolidityPackDecoder for *;\n\n    // Example 1: Map with 2 entries, then more data after\n    function encodeMapThenMoreData() public pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        // Encode a map with 2 entries\n        SPack.map(b, 2);\n        SPack.s(b, \"a\");\n        SPack.u(b, 1);\n        SPack.s(b, \"b\");\n        SPack.u(b, 2);\n        // Map is now complete (2 entries encoded)\n\n        // Now encode MORE items AFTER the map\n        SPack.u(b, 42);\n        SPack.s(b, \"hello\");\n\n        return SPack.done(b);\n        // Result: bytes contain [map, 42, \"hello\"] sequentially\n    }\n\n    // Decode the above: map, then check for more data\n    function decodeMapThenMoreData() public pure returns (\n        uint256 mapValueA,\n        uint256 mapValueB,\n        bool hasMoreData,\n        uint256 afterMapNumber,\n        string memory afterMapString\n    ) {\n        bytes memory data = encodeMapThenMoreData();\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        // Decode the map\n        uint256 mapLen = SolidityPackDecoder.decodeMapLength(dec);\n        require(mapLen == 2, \"Expected 2 entries\");\n\n        SolidityPackDecoder.decodeString(dec); // key \"a\"\n        mapValueA = SolidityPackDecoder.decodeUint(dec);\n\n        SolidityPackDecoder.decodeString(dec); // key \"b\"\n        mapValueB = SolidityPackDecoder.decodeUint(dec);\n\n        // Check if there's more data after the map\n        hasMoreData = SolidityPackDecoder.hasMore(dec);\n\n        // Decode the data after the map\n        if (hasMoreData) {\n            afterMapNumber = SolidityPackDecoder.decodeUint(dec);\n            afterMapString = SolidityPackDecoder.decodeString(dec);\n        }\n\n        return (mapValueA, mapValueB, hasMoreData, afterMapNumber, afterMapString);\n    }\n\n    // Example 2: What if you declare startMap(2) but encode 3 pairs?\n    function encodeMismatchedCount() public pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        SPack.map(b, 2); // Declare 2 entries\n        SPack.s(b, \"first\");\n        SPack.u(b, 1);\n        SPack.s(b, \"second\");\n        SPack.u(b, 2);\n        // Map should be complete according to our declaration\n\n        // But encode a THIRD pair\n        SPack.s(b, \"third\");\n        SPack.u(b, 3);\n\n        return SPack.done(b);\n        // The third pair becomes SEPARATE data after the map!\n    }\n\n    // Decode mismatched: shows \"third\" is outside the map\n    function decodeMismatchedCount() public pure returns (\n        uint256 mapEntryCount,\n        uint256 firstValue,\n        uint256 secondValue,\n        bool hasDataAfterMap,\n        string memory extraKey,\n        uint256 extraValue\n    ) {\n        bytes memory data = encodeMismatchedCount();\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        // Decode the map (declared as 2 entries)\n        mapEntryCount = SolidityPackDecoder.decodeMapLength(dec);\n\n        SolidityPackDecoder.decodeString(dec); // \"first\"\n        firstValue = SolidityPackDecoder.decodeUint(dec);\n\n        SolidityPackDecoder.decodeString(dec); // \"second\"\n        secondValue = SolidityPackDecoder.decodeUint(dec);\n\n        // Map is complete, check for more data\n        hasDataAfterMap = SolidityPackDecoder.hasMore(dec);\n\n        if (hasDataAfterMap) {\n            // The \"third\" entry is OUTSIDE the map!\n            extraKey = SolidityPackDecoder.decodeString(dec);\n            extraValue = SolidityPackDecoder.decodeUint(dec);\n        }\n\n        return (mapEntryCount, firstValue, secondValue, hasDataAfterMap, extraKey, extraValue);\n    }\n\n    // Example 3: Proper way - wrap in array\n    function encodeProperlyWithArray() public pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        // Wrap everything in an array\n        SPack.arr(b, 3);\n        // Element 1: a map\n        SPack.map(b, 2);\n        SPack.s(b, \"a\");\n        SPack.u(b, 1);\n        SPack.s(b, \"b\");\n        SPack.u(b, 2);\n        // Element 2: a number\n        SPack.u(b, 42);\n        // Element 3: a string\n        SPack.s(b, \"hello\");\n        return SPack.done(b);\n    }\n\n    // Example 4: Proper way - wrap in outer map\n    function encodeProperlyWithOuterMap() public pure returns (bytes memory) {\n        SPack.Builder memory b = SPack.builder();\n        // Outer map with 3 entries\n        SPack.map(b, 3);\n        // Entry 1: inner map\n        SPack.s(b, \"data\");\n        SPack.map(b, 2);\n        SPack.s(b, \"a\");\n        SPack.u(b, 1);\n        SPack.s(b, \"b\");\n        SPack.u(b, 2);\n        // Entry 2: number\n        SPack.s(b, \"number\");\n        SPack.u(b, 42);\n        // Entry 3: text\n        SPack.s(b, \"text\");\n        SPack.s(b, \"hello\");\n        return SPack.done(b);\n    }\n\n    // Demonstrate sequential nature of encoding\n    function demonstrateSequentialEncoding() public pure returns (\n        bytes memory justMap,\n        bytes memory mapPlusOne,\n        bytes memory mapPlusTwo,\n        bool lengthsMatch\n    ) {\n        // Encode just the map\n        SPack.Builder memory b1 = SPack.builder();\n        SPack.map(b1, 2);\n        SPack.s(b1, \"a\");\n        SPack.u(b1, 1);\n        SPack.s(b1, \"b\");\n        SPack.u(b1, 2);\n        justMap = SPack.done(b1);\n\n        // Encode map + one more item\n        SPack.Builder memory b2 = SPack.builder();\n        SPack.map(b2, 2);\n        SPack.s(b2, \"a\");\n        SPack.u(b2, 1);\n        SPack.s(b2, \"b\");\n        SPack.u(b2, 2);\n        SPack.u(b2, 42);\n        mapPlusOne = SPack.done(b2);\n\n        // Encode map + two more items\n        mapPlusTwo = encodeMapThenMoreData();\n\n        // The first encoding should be a prefix of the others\n        lengthsMatch = (\n            mapPlusOne.length > justMap.length &&\n            mapPlusTwo.length > mapPlusOne.length\n        );\n\n        return (justMap, mapPlusOne, mapPlusTwo, lengthsMatch);\n    }\n}\n"
      },
      "project/contracts/SolidityPackDecoder.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./SolidityPackTypes.sol\";\n\n/**\n * @title SolidityPackDecoder\n * @notice Ultra gas-efficient decoding for SolidityPack format\n * @dev Decoder-only library to save bytecode in contracts that only decode\n */\n\nlibrary SolidityPackDecoder {\n    using SolidityPackTypes for *;\n\n    // ============ TYPE CATEGORIES ============\n\n    enum TypeCategory {\n        NIL,\n        BOOL,\n        UINT,\n        INT,\n        BYTES,\n        STRING,\n        ARRAY,\n        MAP,\n        ADDRESS,\n        BYTES32\n    }\n\n    // ============ GENERIC TYPE INSPECTION ============\n\n    /**\n     * @notice Get the category of the next value without consuming it\n     * @dev Useful for dynamic decoding when you don't know the type ahead of time\n     */\n    function peekCategory(SolidityPackTypes.Decoder memory dec) internal pure returns (TypeCategory) {\n        require(dec.pos < dec.data.length, \"EOF\");\n        uint8 tag = uint8(dec.data[dec.pos]);\n\n        if (tag == SolidityPackTypes.NIL) {\n            return TypeCategory.NIL;\n        } else if (tag == SolidityPackTypes.TRUE || tag == SolidityPackTypes.FALSE) {\n            return TypeCategory.BOOL;\n        } else if (\n            tag <= SolidityPackTypes.FIXINT_POS_MAX ||\n            tag == SolidityPackTypes.UINT8 ||\n            tag == SolidityPackTypes.UINT16 ||\n            tag == SolidityPackTypes.UINT32 ||\n            tag == SolidityPackTypes.UINT64 ||\n            tag == SolidityPackTypes.UINT128 ||\n            tag == SolidityPackTypes.UINT256\n        ) {\n            return TypeCategory.UINT;\n        } else if (\n            tag >= SolidityPackTypes.FIXINT_NEG_BASE ||\n            tag == SolidityPackTypes.INT8 ||\n            tag == SolidityPackTypes.INT16 ||\n            tag == SolidityPackTypes.INT32 ||\n            tag == SolidityPackTypes.INT64 ||\n            tag == SolidityPackTypes.INT128 ||\n            tag == SolidityPackTypes.INT256\n        ) {\n            return TypeCategory.INT;\n        } else if (tag == SolidityPackTypes.BYTES8 || tag == SolidityPackTypes.BYTES16) {\n            return TypeCategory.BYTES;\n        } else if (\n            (tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32) ||\n            tag == SolidityPackTypes.STR8 ||\n            tag == SolidityPackTypes.STR16\n        ) {\n            return TypeCategory.STRING;\n        } else if (\n            (tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16) ||\n            tag == SolidityPackTypes.ARRAY8 ||\n            tag == SolidityPackTypes.ARRAY16\n        ) {\n            return TypeCategory.ARRAY;\n        } else if (\n            (tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16) ||\n            tag == SolidityPackTypes.MAP8 ||\n            tag == SolidityPackTypes.MAP16\n        ) {\n            return TypeCategory.MAP;\n        } else if (tag == SolidityPackTypes.ADDRESS) {\n            return TypeCategory.ADDRESS;\n        } else if (tag == SolidityPackTypes.BYTES32_TYPE) {\n            return TypeCategory.BYTES32;\n        }\n\n        revert(\"Unknown type tag\");\n    }\n\n    /**\n     * @notice Check if the next value is of a specific category\n     * @dev Useful for conditional decoding\n     */\n    function isCategory(\n        SolidityPackTypes.Decoder memory dec,\n        TypeCategory category\n    ) internal pure returns (bool) {\n        if (dec.pos >= dec.data.length) return false;\n        return peekCategory(dec) == category;\n    }\n\n    /**\n     * @notice Check if decoder has more data to read\n     */\n    function hasMore(SolidityPackTypes.Decoder memory dec) internal pure returns (bool) {\n        return dec.pos < dec.data.length;\n    }\n\n    // ============ DECODER FUNCTIONS ============\n\n    function newDecoder(bytes memory data) internal pure returns (SolidityPackTypes.Decoder memory) {\n        return SolidityPackTypes.Decoder(data, 0);\n    }\n\n    function peekType(SolidityPackTypes.Decoder memory dec) internal pure returns (uint8) {\n        require(dec.pos < dec.data.length, \"EOF\");\n        return uint8(dec.data[dec.pos]);\n    }\n\n    function decodeBool(SolidityPackTypes.Decoder memory dec) internal pure returns (bool) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n        require(tag == SolidityPackTypes.TRUE || tag == SolidityPackTypes.FALSE, \"Not bool\");\n        return tag == SolidityPackTypes.TRUE;\n    }\n\n    function decodeNil(SolidityPackTypes.Decoder memory dec) internal pure {\n        require(peekType(dec) == SolidityPackTypes.NIL, \"Not nil\");\n        dec.pos++;\n    }\n\n    function decodeUint(SolidityPackTypes.Decoder memory dec) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX) {\n            return uint256(tag);\n        } else if (tag == SolidityPackTypes.UINT8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.UINT16) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(shl(8, byte(0, mload(ptr))), byte(0, mload(add(ptr, 1))))\n            }\n            dec.pos += 2;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT32) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(\n                    or(\n                        or(shl(24, byte(0, mload(ptr))), shl(16, byte(0, mload(add(ptr, 1))))),\n                        shl(8, byte(0, mload(add(ptr, 2))))\n                    ),\n                    byte(0, mload(add(ptr, 3)))\n                )\n            }\n            dec.pos += 4;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT64) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := 0\n                for { let i := 0 } lt(i, 8) { i := add(i, 1) } {\n                    val := or(shl(8, val), byte(0, mload(add(ptr, i))))\n                }\n            }\n            dec.pos += 8;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT128) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := 0\n                for { let i := 0 } lt(i, 16) { i := add(i, 1) } {\n                    val := or(shl(8, val), byte(0, mload(add(ptr, i))))\n                }\n            }\n            dec.pos += 16;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT256) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := mload(ptr)\n            }\n            dec.pos += 32;\n            return val;\n        }\n\n        revert(\"Invalid uint tag\");\n    }\n\n    function decodeInt(SolidityPackTypes.Decoder memory dec) internal pure returns (int256) {\n        uint8 tag = peekType(dec);\n\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX) {\n            dec.pos++;\n            return int256(uint256(tag));\n        } else if (tag >= SolidityPackTypes.FIXINT_NEG_BASE) {\n            dec.pos++;\n            return\n                int8(uint8(tag)) -\n                int8(uint8(SolidityPackTypes.FIXINT_NEG_BASE)) -\n                32;\n        }\n\n        dec.pos++;\n\n        if (tag == SolidityPackTypes.INT8) {\n            return int8(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.INT16) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(shl(8, byte(0, mload(ptr))), byte(0, mload(add(ptr, 1))))\n                // Use signextend opcode\n                val := signextend(1, val)\n            }\n            dec.pos += 2;\n            return int256(val);\n        } else if (tag == SolidityPackTypes.INT32) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(\n                    or(\n                        or(shl(24, byte(0, mload(ptr))), shl(16, byte(0, mload(add(ptr, 1))))),\n                        shl(8, byte(0, mload(add(ptr, 2))))\n                    ),\n                    byte(0, mload(add(ptr, 3)))\n                )\n                // Use signextend opcode\n                val := signextend(3, val)\n            }\n            dec.pos += 4;\n            return int256(val);\n        } else if (tag == SolidityPackTypes.INT256) {\n            int256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := mload(ptr)\n            }\n            dec.pos += 32;\n            return val;\n        }\n\n        revert(\"Invalid int tag\");\n    }\n\n    function decodeAddress(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (address) {\n        require(peekType(dec) == SolidityPackTypes.ADDRESS, \"Not address\");\n        dec.pos++;\n        address val;\n        assembly {\n            let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n            val := shr(96, mload(ptr))\n        }\n        dec.pos += 20;\n        return val;\n    }\n\n    function decodeBytes32(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (bytes32) {\n        require(peekType(dec) == SolidityPackTypes.BYTES32_TYPE, \"Not bytes32\");\n        dec.pos++;\n        bytes32 val;\n        assembly {\n            let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n            val := mload(ptr)\n        }\n        dec.pos += 32;\n        return val;\n    }\n\n    function decodeBytes(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (bytes memory) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        uint256 len;\n        if (tag == SolidityPackTypes.BYTES8) {\n            len = uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.BYTES16) {\n            len =\n                (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n        } else {\n            revert(\"Not bytes\");\n        }\n\n        bytes memory result = new bytes(len);\n        assembly {\n            let src := add(add(mload(dec), 32), mload(add(dec, 32)))\n            let dst := add(result, 32)\n\n            // Copy full 32-byte chunks\n            let fullChunks := div(len, 32)\n            for { let i := 0 } lt(i, fullChunks) { i := add(i, 1) } {\n                mstore(add(dst, mul(i, 32)), mload(add(src, mul(i, 32))))\n            }\n\n            // Copy remaining bytes if any\n            let remaining := mod(len, 32)\n            if gt(remaining, 0) {\n                let lastChunkOffset := mul(fullChunks, 32)\n                let mask := sub(shl(mul(remaining, 8), 1), 1)\n                let srcData := and(\n                    mload(add(src, lastChunkOffset)),\n                    shl(sub(256, mul(remaining, 8)), mask)\n                )\n                mstore(add(dst, lastChunkOffset), srcData)\n            }\n        }\n        dec.pos += len;\n        return result;\n    }\n\n    function decodeString(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (string memory) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        uint256 len;\n        if (tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32) {\n            len = uint256(tag - SolidityPackTypes.FIXSTR_BASE);\n        } else if (tag == SolidityPackTypes.STR8) {\n            len = uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.STR16) {\n            len =\n                (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n        } else {\n            revert(\"Not string\");\n        }\n\n        bytes memory result = new bytes(len);\n        assembly {\n            let src := add(add(mload(dec), 32), mload(add(dec, 32)))\n            let dst := add(result, 32)\n\n            // Copy full 32-byte chunks\n            let fullChunks := div(len, 32)\n            for { let i := 0 } lt(i, fullChunks) { i := add(i, 1) } {\n                mstore(add(dst, mul(i, 32)), mload(add(src, mul(i, 32))))\n            }\n\n            // Copy remaining bytes if any\n            let remaining := mod(len, 32)\n            if gt(remaining, 0) {\n                let lastChunkOffset := mul(fullChunks, 32)\n                let mask := sub(shl(mul(remaining, 8), 1), 1)\n                let srcData := and(\n                    mload(add(src, lastChunkOffset)),\n                    shl(sub(256, mul(remaining, 8)), mask)\n                )\n                mstore(add(dst, lastChunkOffset), srcData)\n            }\n        }\n        dec.pos += len;\n        return string(result);\n    }\n\n    function decodeArrayLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16) {\n            return uint256(tag - SolidityPackTypes.FIXARRAY_BASE);\n        } else if (tag == SolidityPackTypes.ARRAY8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.ARRAY16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            return len;\n        }\n\n        revert(\"Not array\");\n    }\n\n    function decodeMapLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16) {\n            return uint256(tag - SolidityPackTypes.FIXMAP_BASE);\n        } else if (tag == SolidityPackTypes.MAP8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.MAP16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            return len;\n        }\n\n        revert(\"Not map\");\n    }\n\n    // ============ NESTED OBJECT DECODING ============\n\n    /**\n     * @notice Start decoding a nested object (map)\n     * @return Number of key-value pairs\n     */\n    function decodeObjectLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        return decodeMapLength(dec);\n    }\n\n    /**\n     * @notice Helper to decode array of uints\n     */\n    function decodeUintArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        uint256[] memory result = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeUint(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Helper to decode array of addresses\n     */\n    function decodeAddressArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (address[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        address[] memory result = new address[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeAddress(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Helper to decode array of strings\n     */\n    function decodeStringArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (string[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        string[] memory result = new string[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeString(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Skip the next value in the decoder (useful for unknown fields)\n     */\n    function skip(SolidityPackTypes.Decoder memory dec) internal pure {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        // Handle different type categories\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX || tag >= SolidityPackTypes.FIXINT_NEG_BASE) {\n            // Fixint, already consumed\n            return;\n        } else if (\n            tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32\n        ) {\n            // Fixstr\n            dec.pos += (tag - SolidityPackTypes.FIXSTR_BASE);\n        } else if (\n            tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16\n        ) {\n            // Fixarray\n            uint256 len = tag - SolidityPackTypes.FIXARRAY_BASE;\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (\n            tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16\n        ) {\n            // Fixmap\n            uint256 len = tag - SolidityPackTypes.FIXMAP_BASE;\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else if (\n            tag == SolidityPackTypes.NIL ||\n            tag == SolidityPackTypes.TRUE ||\n            tag == SolidityPackTypes.FALSE\n        ) {\n            // Already consumed\n        } else if (tag == SolidityPackTypes.UINT8 || tag == SolidityPackTypes.INT8) {\n            dec.pos += 1;\n        } else if (tag == SolidityPackTypes.UINT16 || tag == SolidityPackTypes.INT16) {\n            dec.pos += 2;\n        } else if (tag == SolidityPackTypes.UINT32 || tag == SolidityPackTypes.INT32) {\n            dec.pos += 4;\n        } else if (tag == SolidityPackTypes.UINT64 || tag == SolidityPackTypes.INT64) {\n            dec.pos += 8;\n        } else if (tag == SolidityPackTypes.UINT128 || tag == SolidityPackTypes.INT128) {\n            dec.pos += 16;\n        } else if (\n            tag == SolidityPackTypes.UINT256 ||\n            tag == SolidityPackTypes.INT256 ||\n            tag == SolidityPackTypes.BYTES32_TYPE\n        ) {\n            dec.pos += 32;\n        } else if (tag == SolidityPackTypes.ADDRESS) {\n            dec.pos += 20;\n        } else if (tag == SolidityPackTypes.BYTES8 || tag == SolidityPackTypes.STR8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            dec.pos += len;\n        } else if (tag == SolidityPackTypes.BYTES16 || tag == SolidityPackTypes.STR16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2 + len;\n        } else if (tag == SolidityPackTypes.ARRAY8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.ARRAY16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.MAP8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.MAP16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else {\n            revert(\"Unknown type tag\");\n        }\n    }\n}\n"
      },
      "project/contracts/SolidityPackTypes.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title SolidityPackTypes\n * @notice Shared type constants and structs for SolidityPack encoding/decoding\n * @dev This library contains only constants and is optimized away at compile time\n */\n\nlibrary SolidityPackTypes {\n\n    // Type constants\n    uint8 internal constant FIXINT_POS_MAX = 0x7F;\n    uint8 internal constant FIXMAP_BASE = 0x80;\n    uint8 internal constant FIXARRAY_BASE = 0x90;\n    uint8 internal constant FIXSTR_BASE = 0xA0;\n    uint8 internal constant NIL = 0xC0;\n    uint8 internal constant FALSE = 0xC2;\n    uint8 internal constant TRUE = 0xC3;\n    uint8 internal constant UINT8 = 0xC4;\n    uint8 internal constant UINT16 = 0xC5;\n    uint8 internal constant UINT32 = 0xC6;\n    uint8 internal constant UINT64 = 0xC7;\n    uint8 internal constant UINT128 = 0xC8;\n    uint8 internal constant UINT256 = 0xC9;\n    uint8 internal constant INT8 = 0xCA;\n    uint8 internal constant INT16 = 0xCB;\n    uint8 internal constant INT32 = 0xCC;\n    uint8 internal constant INT64 = 0xCD;\n    uint8 internal constant INT128 = 0xCE;\n    uint8 internal constant INT256 = 0xCF;\n    uint8 internal constant BYTES8 = 0xD0;\n    uint8 internal constant BYTES16 = 0xD1;\n    uint8 internal constant STR8 = 0xD2;\n    uint8 internal constant STR16 = 0xD3;\n    uint8 internal constant ADDRESS = 0xD4;\n    uint8 internal constant BYTES32_TYPE = 0xD5;\n    uint8 internal constant ARRAY8 = 0xD6;\n    uint8 internal constant ARRAY16 = 0xD7;\n    uint8 internal constant MAP8 = 0xD8;\n    uint8 internal constant MAP16 = 0xD9;\n    uint8 internal constant FIXINT_NEG_BASE = 0xE0;\n\n    // Growth strategy constants for encoder\n    uint256 internal constant INITIAL_BUFFER_SIZE = 256;\n    uint256 internal constant GROWTH_THRESHOLD = 4096;\n    uint256 internal constant MIN_GROWTH_MARGIN = 128;\n\n    // Encoder struct\n    struct Encoder {\n        bytes buffer;\n        uint256 pos;\n    }\n\n    // Decoder struct\n    struct Decoder {\n        bytes data;\n        uint256 pos;\n    }\n}\n"
      },
      "project/contracts/SPack.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./SolidityPackTypes.sol\";\n\n/**\n * @title SPack\n * @notice Simplified, less verbose API with reduced bytecode usage\n * @dev Key improvements:\n *  - Direct encode functions (no Encoder management needed for simple cases)\n *  - Batch encoding helpers\n *  - Shorter function names\n *  - Automatic capacity management\n */\n\nlibrary SPack {\n    using SolidityPackTypes for *;\n\n    // ============ SIMPLIFIED DIRECT ENCODING ============\n    // For simple cases where you just want bytes back\n\n    function encode(bool value) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(1);\n        result[0] = bytes1(value ? SolidityPackTypes.TRUE : SolidityPackTypes.FALSE);\n        return result;\n    }\n\n    function encode(uint256 value) internal pure returns (bytes memory) {\n        if (value <= 127) {\n            bytes memory result = new bytes(1);\n            result[0] = bytes1(uint8(value));\n            return result;\n        }\n        // Fallback to full encoder for larger values\n        return _encodeUintFull(value);\n    }\n\n    function encode(int256 value) internal pure returns (bytes memory) {\n        if (value >= 0 && value <= 127) {\n            bytes memory result = new bytes(1);\n            result[0] = bytes1(uint8(int8(value)));\n            return result;\n        }\n        return _encodeIntFull(value);\n    }\n\n    function encode(address value) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(21);\n        result[0] = bytes1(SolidityPackTypes.ADDRESS);\n        assembly (\"memory-safe\") {\n            mstore(add(result, 33), shl(96, value))\n        }\n        return result;\n    }\n\n    function encode(string memory value) internal pure returns (bytes memory) {\n        return _encodeStringDirect(value);\n    }\n\n    function encode(bytes memory value) internal pure returns (bytes memory) {\n        return _encodeBytesDirect(value);\n    }\n\n    // ============ BATCH ENCODING (Most gas efficient) ============\n\n    /// @notice Encode multiple uints in one go\n    function pack(uint256 a, uint256 b) internal pure returns (bytes memory) {\n        SolidityPackTypes.Encoder memory e = _new();\n        _uint(e, a);\n        _uint(e, b);\n        return _done(e);\n    }\n\n    function pack(uint256 a, uint256 b, uint256 c) internal pure returns (bytes memory) {\n        SolidityPackTypes.Encoder memory e = _new();\n        _uint(e, a);\n        _uint(e, b);\n        _uint(e, c);\n        return _done(e);\n    }\n\n    function pack(address a, uint256 b) internal pure returns (bytes memory) {\n        SolidityPackTypes.Encoder memory e = _new();\n        _addr(e, a);\n        _uint(e, b);\n        return _done(e);\n    }\n\n    function pack(address a, address b, uint256 c) internal pure returns (bytes memory) {\n        SolidityPackTypes.Encoder memory e = _new();\n        _addr(e, a);\n        _addr(e, b);\n        _uint(e, c);\n        return _done(e);\n    }\n\n    // ============ BUILDER API (For complex encoding) ============\n\n    struct Builder {\n        bytes buffer;\n        uint256 pos;\n    }\n\n    /// @notice Start building an encoded message\n    function builder() internal pure returns (Builder memory) {\n        return Builder(new bytes(256), 0);\n    }\n\n    /// @notice Encode uint (chainable)\n    function u(Builder memory b, uint256 v) internal pure returns (Builder memory) {\n        _ensureSpace(b, 33);\n        _writeUint(b, v);\n        return b;\n    }\n\n    /// @notice Encode int (chainable)\n    function i(Builder memory b, int256 v) internal pure returns (Builder memory) {\n        _ensureSpace(b, 33);\n        _writeInt(b, v);\n        return b;\n    }\n\n    /// @notice Encode address (chainable)\n    function a(Builder memory b, address v) internal pure returns (Builder memory) {\n        _ensureSpace(b, 21);\n        _writeAddr(b, v);\n        return b;\n    }\n\n    /// @notice Encode string (chainable)\n    function s(Builder memory b, string memory v) internal pure returns (Builder memory) {\n        _ensureSpace(b, bytes(v).length + 3);\n        _writeString(b, v);\n        return b;\n    }\n\n    /// @notice Encode bytes (chainable)\n    function b(Builder memory b, bytes memory v) internal pure returns (Builder memory) {\n        _ensureSpace(b, v.length + 3);\n        _writeBytes(b, v);\n        return b;\n    }\n\n    /// @notice Encode bool (chainable)\n    function bool_(Builder memory b, bool v) internal pure returns (Builder memory) {\n        _ensureSpace(b, 1);\n        b.buffer[b.pos++] = bytes1(v ? SolidityPackTypes.TRUE : SolidityPackTypes.FALSE);\n        return b;\n    }\n\n    /// @notice Encode bytes32 (chainable)\n    function b32(Builder memory b, bytes32 v) internal pure returns (Builder memory) {\n        _ensureSpace(b, 34);\n        _writeBytes32(b, v);\n        return b;\n    }\n\n    /// @notice Encode nil (chainable)\n    function nil(Builder memory b) internal pure returns (Builder memory) {\n        _ensureSpace(b, 1);\n        b.buffer[b.pos++] = bytes1(SolidityPackTypes.NIL);\n        return b;\n    }\n\n    /// @notice Start array (chainable)\n    function arr(Builder memory b, uint256 len) internal pure returns (Builder memory) {\n        _ensureSpace(b, 3);\n        _writeArrayStart(b, len);\n        return b;\n    }\n\n    /// @notice Start map (chainable)\n    function map(Builder memory b, uint256 len) internal pure returns (Builder memory) {\n        _ensureSpace(b, 3);\n        _writeMapStart(b, len);\n        return b;\n    }\n\n    /// @notice Finalize and return encoded bytes\n    function done(Builder memory b) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(b.pos);\n        assembly (\"memory-safe\") {\n            let src := add(mload(b), 32)\n            let dst := add(result, 32)\n            let len := mload(add(b, 32))\n            let end := add(src, len)\n\n            for { } lt(src, end) { } {\n                mstore(dst, mload(src))\n                src := add(src, 32)\n                dst := add(dst, 32)\n            }\n        }\n        return result;\n    }\n\n    // ============ COMMON PATTERNS ============\n\n    /// @notice Encode array of uints\n    function array(uint256[] memory values) internal pure returns (bytes memory) {\n        Builder memory b = builder();\n        arr(b, values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            u(b, values[i]);\n        }\n        return done(b);\n    }\n\n    /// @notice Encode array of addresses\n    function array(address[] memory values) internal pure returns (bytes memory) {\n        Builder memory b = builder();\n        arr(b, values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            a(b, values[i]);\n        }\n        return done(b);\n    }\n\n    /// @notice Encode array of strings\n    function array(string[] memory values) internal pure returns (bytes memory) {\n        Builder memory b = builder();\n        arr(b, values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            s(b, values[i]);\n        }\n        return done(b);\n    }\n\n    /// @notice Encode simple object with string keys\n    function object(\n        string memory k1, uint256 v1,\n        string memory k2, uint256 v2\n    ) internal pure returns (bytes memory) {\n        Builder memory b = builder();\n        map(b, 2);\n        s(b, k1); u(b, v1);\n        s(b, k2); u(b, v2);\n        return done(b);\n    }\n\n    function object(\n        string memory k1, uint256 v1,\n        string memory k2, address v2\n    ) internal pure returns (bytes memory) {\n        Builder memory b = builder();\n        map(b, 2);\n        s(b, k1); u(b, v1);\n        s(b, k2); a(b, v2);\n        return done(b);\n    }\n\n    // ============ INTERNAL WRITE FUNCTIONS ============\n\n    function _writeUint(Builder memory b, uint256 value) private pure {\n        if (value <= 127) {\n            b.buffer[b.pos++] = bytes1(uint8(value));\n        } else if (value <= type(uint8).max) {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.UINT8);\n            b.buffer[b.pos++] = bytes1(uint8(value));\n        } else if (value <= type(uint16).max) {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.UINT16);\n            assembly (\"memory-safe\") {\n                let ptr := add(add(mload(b), 32), mload(add(b, 32)))\n                mstore8(ptr, shr(8, value))\n                mstore8(add(ptr, 1), value)\n            }\n            b.pos += 2;\n        } else if (value <= type(uint32).max) {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.UINT32);\n            assembly (\"memory-safe\") {\n                let ptr := add(add(mload(b), 32), mload(add(b, 32)))\n                mstore8(ptr, shr(24, value))\n                mstore8(add(ptr, 1), shr(16, value))\n                mstore8(add(ptr, 2), shr(8, value))\n                mstore8(add(ptr, 3), value)\n            }\n            b.pos += 4;\n        } else if (value <= type(uint64).max) {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.UINT64);\n            assembly (\"memory-safe\") {\n                let ptr := add(add(mload(b), 32), mload(add(b, 32)))\n                mstore8(ptr, shr(56, value))\n                mstore8(add(ptr, 1), shr(48, value))\n                mstore8(add(ptr, 2), shr(40, value))\n                mstore8(add(ptr, 3), shr(32, value))\n                mstore8(add(ptr, 4), shr(24, value))\n                mstore8(add(ptr, 5), shr(16, value))\n                mstore8(add(ptr, 6), shr(8, value))\n                mstore8(add(ptr, 7), value)\n            }\n            b.pos += 8;\n        } else {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.UINT256);\n            assembly (\"memory-safe\") {\n                let ptr := add(add(mload(b), 32), mload(add(b, 32)))\n                mstore(ptr, value)\n            }\n            b.pos += 32;\n        }\n    }\n\n    function _writeInt(Builder memory b, int256 value) private pure {\n        if (value >= 0) {\n            _writeUint(b, uint256(value));\n        } else if (value >= -32) {\n            b.buffer[b.pos++] = bytes1(\n                uint8(SolidityPackTypes.FIXINT_NEG_BASE + uint8(int8(value + 32)))\n            );\n        } else if (value >= type(int8).min) {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.INT8);\n            b.buffer[b.pos++] = bytes1(uint8(int8(value)));\n        } else {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.INT256);\n            assembly (\"memory-safe\") {\n                let ptr := add(add(mload(b), 32), mload(add(b, 32)))\n                mstore(ptr, value)\n            }\n            b.pos += 32;\n        }\n    }\n\n    function _writeAddr(Builder memory b, address value) private pure {\n        b.buffer[b.pos++] = bytes1(SolidityPackTypes.ADDRESS);\n        assembly (\"memory-safe\") {\n            let ptr := add(add(mload(b), 32), mload(add(b, 32)))\n            mstore(ptr, shl(96, value))\n        }\n        b.pos += 20;\n    }\n\n    function _writeString(Builder memory b, string memory value) private pure {\n        bytes memory byt = bytes(value);\n        uint256 len = byt.length;\n\n        if (len <= 31) {\n            b.buffer[b.pos++] = bytes1(uint8(SolidityPackTypes.FIXSTR_BASE + len));\n        } else if (len <= 255) {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.STR8);\n            b.buffer[b.pos++] = bytes1(uint8(len));\n        } else {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.STR16);\n            b.buffer[b.pos++] = bytes1(uint8(len >> 8));\n            b.buffer[b.pos++] = bytes1(uint8(len));\n        }\n\n        assembly (\"memory-safe\") {\n            let src := add(byt, 32)\n            let dst := add(add(mload(b), 32), mload(add(b, 32)))\n            let end := add(src, len)\n\n            for { } lt(src, end) { } {\n                mstore(dst, mload(src))\n                src := add(src, 32)\n                dst := add(dst, 32)\n            }\n        }\n        b.pos += len;\n    }\n\n    function _writeBytes(Builder memory b, bytes memory value) private pure {\n        uint256 len = value.length;\n\n        if (len <= 255) {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.BYTES8);\n            b.buffer[b.pos++] = bytes1(uint8(len));\n        } else {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.BYTES16);\n            b.buffer[b.pos++] = bytes1(uint8(len >> 8));\n            b.buffer[b.pos++] = bytes1(uint8(len));\n        }\n\n        assembly (\"memory-safe\") {\n            let src := add(value, 32)\n            let dst := add(add(mload(b), 32), mload(add(b, 32)))\n            let end := add(src, len)\n\n            for { } lt(src, end) { } {\n                mstore(dst, mload(src))\n                src := add(src, 32)\n                dst := add(dst, 32)\n            }\n        }\n        b.pos += len;\n    }\n\n    function _writeBytes32(Builder memory b, bytes32 value) private pure {\n        b.buffer[b.pos++] = bytes1(SolidityPackTypes.BYTES32_TYPE);\n        assembly (\"memory-safe\") {\n            let ptr := add(add(mload(b), 32), mload(add(b, 32)))\n            mstore(ptr, value)\n        }\n        b.pos += 32;\n    }\n\n    function _writeArrayStart(Builder memory b, uint256 len) private pure {\n        if (len <= 15) {\n            b.buffer[b.pos++] = bytes1(uint8(SolidityPackTypes.FIXARRAY_BASE + len));\n        } else if (len <= 255) {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.ARRAY8);\n            b.buffer[b.pos++] = bytes1(uint8(len));\n        } else {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.ARRAY16);\n            b.buffer[b.pos++] = bytes1(uint8(len >> 8));\n            b.buffer[b.pos++] = bytes1(uint8(len));\n        }\n    }\n\n    function _writeMapStart(Builder memory b, uint256 len) private pure {\n        if (len <= 15) {\n            b.buffer[b.pos++] = bytes1(uint8(SolidityPackTypes.FIXMAP_BASE + len));\n        } else if (len <= 255) {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.MAP8);\n            b.buffer[b.pos++] = bytes1(uint8(len));\n        } else {\n            b.buffer[b.pos++] = bytes1(SolidityPackTypes.MAP16);\n            b.buffer[b.pos++] = bytes1(uint8(len >> 8));\n            b.buffer[b.pos++] = bytes1(uint8(len));\n        }\n    }\n\n    function _ensureSpace(Builder memory b, uint256 required) private pure {\n        uint256 needed = b.pos + required;\n        if (needed <= b.buffer.length) return;\n\n        uint256 newSize = b.buffer.length * 2;\n        if (newSize < needed) newSize = needed + 64;\n\n        bytes memory newBuffer = new bytes(newSize);\n        assembly (\"memory-safe\") {\n            let src := add(mload(b), 32)\n            let dst := add(newBuffer, 32)\n            let len := mload(add(b, 32))\n            let end := add(src, len)\n\n            for { } lt(src, end) { } {\n                mstore(dst, mload(src))\n                src := add(src, 32)\n                dst := add(dst, 32)\n            }\n        }\n        b.buffer = newBuffer;\n    }\n\n    // ============ HELPER FUNCTIONS FOR SIMPLE ENCODING ============\n\n    function _encodeUintFull(uint256 value) private pure returns (bytes memory) {\n        if (value <= type(uint8).max) {\n            bytes memory result = new bytes(2);\n            result[0] = bytes1(SolidityPackTypes.UINT8);\n            result[1] = bytes1(uint8(value));\n            return result;\n        }\n        if (value <= type(uint16).max) {\n            bytes memory result = new bytes(3);\n            result[0] = bytes1(SolidityPackTypes.UINT16);\n            result[1] = bytes1(uint8(value >> 8));\n            result[2] = bytes1(uint8(value));\n            return result;\n        }\n        if (value <= type(uint32).max) {\n            bytes memory result = new bytes(5);\n            result[0] = bytes1(SolidityPackTypes.UINT32);\n            assembly (\"memory-safe\") {\n                let ptr := add(result, 33)\n                mstore8(ptr, shr(24, value))\n                mstore8(add(ptr, 1), shr(16, value))\n                mstore8(add(ptr, 2), shr(8, value))\n                mstore8(add(ptr, 3), value)\n            }\n            return result;\n        }\n        // Full uint256\n        bytes memory result = new bytes(33);\n        result[0] = bytes1(SolidityPackTypes.UINT256);\n        assembly (\"memory-safe\") {\n            mstore(add(result, 33), value)\n        }\n        return result;\n    }\n\n    function _encodeIntFull(int256 value) private pure returns (bytes memory) {\n        if (value >= 0) return _encodeUintFull(uint256(value));\n\n        if (value >= -32) {\n            bytes memory result = new bytes(1);\n            result[0] = bytes1(uint8(SolidityPackTypes.FIXINT_NEG_BASE + uint8(int8(value + 32))));\n            return result;\n        }\n\n        bytes memory result = new bytes(33);\n        result[0] = bytes1(SolidityPackTypes.INT256);\n        assembly (\"memory-safe\") {\n            mstore(add(result, 33), value)\n        }\n        return result;\n    }\n\n    function _encodeStringDirect(string memory value) private pure returns (bytes memory) {\n        bytes memory byt = bytes(value);\n        uint256 len = byt.length;\n        bytes memory result;\n\n        if (len <= 31) {\n            result = new bytes(len + 1);\n            result[0] = bytes1(uint8(SolidityPackTypes.FIXSTR_BASE + len));\n            for (uint256 i = 0; i < len; i++) {\n                result[i + 1] = byt[i];\n            }\n        } else if (len <= 255) {\n            result = new bytes(len + 2);\n            result[0] = bytes1(SolidityPackTypes.STR8);\n            result[1] = bytes1(uint8(len));\n            for (uint256 i = 0; i < len; i++) {\n                result[i + 2] = byt[i];\n            }\n        } else {\n            result = new bytes(len + 3);\n            result[0] = bytes1(SolidityPackTypes.STR16);\n            result[1] = bytes1(uint8(len >> 8));\n            result[2] = bytes1(uint8(len));\n            for (uint256 i = 0; i < len; i++) {\n                result[i + 3] = byt[i];\n            }\n        }\n        return result;\n    }\n\n    function _encodeBytesDirect(bytes memory value) private pure returns (bytes memory) {\n        uint256 len = value.length;\n        bytes memory result;\n\n        if (len <= 255) {\n            result = new bytes(len + 2);\n            result[0] = bytes1(SolidityPackTypes.BYTES8);\n            result[1] = bytes1(uint8(len));\n            for (uint256 i = 0; i < len; i++) {\n                result[i + 2] = value[i];\n            }\n        } else {\n            result = new bytes(len + 3);\n            result[0] = bytes1(SolidityPackTypes.BYTES16);\n            result[1] = bytes1(uint8(len >> 8));\n            result[2] = bytes1(uint8(len));\n            for (uint256 i = 0; i < len; i++) {\n                result[i + 3] = value[i];\n            }\n        }\n        return result;\n    }\n\n    // Compatibility with old API\n    function _new() private pure returns (SolidityPackTypes.Encoder memory) {\n        return SolidityPackTypes.Encoder(new bytes(256), 0);\n    }\n\n    function _uint(SolidityPackTypes.Encoder memory e, uint256 v) private pure {\n        _ensureCapacityOld(e, 33);\n        _writeUintOld(e, v);\n    }\n\n    function _addr(SolidityPackTypes.Encoder memory e, address v) private pure {\n        _ensureCapacityOld(e, 21);\n        e.buffer[e.pos++] = bytes1(SolidityPackTypes.ADDRESS);\n        assembly (\"memory-safe\") {\n            let ptr := add(add(mload(e), 32), mload(add(e, 32)))\n            mstore(ptr, shl(96, v))\n        }\n        e.pos += 20;\n    }\n\n    function _done(SolidityPackTypes.Encoder memory e) private pure returns (bytes memory) {\n        bytes memory result = new bytes(e.pos);\n        assembly (\"memory-safe\") {\n            let src := add(mload(e), 32)\n            let dst := add(result, 32)\n            let len := mload(add(e, 32))\n            let end := add(src, len)\n\n            for { } lt(src, end) { } {\n                mstore(dst, mload(src))\n                src := add(src, 32)\n                dst := add(dst, 32)\n            }\n        }\n        return result;\n    }\n\n    function _writeUintOld(SolidityPackTypes.Encoder memory e, uint256 value) private pure {\n        if (value <= 127) {\n            e.buffer[e.pos++] = bytes1(uint8(value));\n        } else if (value <= type(uint8).max) {\n            e.buffer[e.pos++] = bytes1(SolidityPackTypes.UINT8);\n            e.buffer[e.pos++] = bytes1(uint8(value));\n        } else if (value <= type(uint32).max) {\n            e.buffer[e.pos++] = bytes1(SolidityPackTypes.UINT32);\n            assembly (\"memory-safe\") {\n                let ptr := add(add(mload(e), 32), mload(add(e, 32)))\n                mstore8(ptr, shr(24, value))\n                mstore8(add(ptr, 1), shr(16, value))\n                mstore8(add(ptr, 2), shr(8, value))\n                mstore8(add(ptr, 3), value)\n            }\n            e.pos += 4;\n        } else {\n            e.buffer[e.pos++] = bytes1(SolidityPackTypes.UINT256);\n            assembly (\"memory-safe\") {\n                let ptr := add(add(mload(e), 32), mload(add(e, 32)))\n                mstore(ptr, value)\n            }\n            e.pos += 32;\n        }\n    }\n\n    function _ensureCapacityOld(SolidityPackTypes.Encoder memory e, uint256 required) private pure {\n        uint256 needed = e.pos + required;\n        if (needed <= e.buffer.length) return;\n\n        uint256 newSize = e.buffer.length * 2;\n        if (newSize < needed) newSize = needed + 64;\n\n        bytes memory newBuffer = new bytes(newSize);\n        assembly (\"memory-safe\") {\n            let src := add(mload(e), 32)\n            let dst := add(newBuffer, 32)\n            let len := mload(add(e, 32))\n            let end := add(src, len)\n\n            for { } lt(src, end) { } {\n                mstore(dst, mload(src))\n                src := add(src, 32)\n                dst := add(dst, 32)\n            }\n        }\n        e.buffer = newBuffer;\n    }\n}\n"
      }
    }
  }
}